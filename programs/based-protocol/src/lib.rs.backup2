#[cfg(not(feature = "no-entrypoint"))]
use solana_security_txt::security_txt;

#[cfg(not(feature = "no-entrypoint"))]
security_txt! {
    name: "BASED Protocol",
    project_url: "https://github.com/basedprotocol/based-protocol",
    contacts: "email:fytsfitness@gmail.com",
    policy: "https://github.com/basedprotocol/based-protocol/blob/master/SECURITY.md",
    preferred_languages: "en",
    source_code: "https://github.com/basedprotocol/based-protocol"
}

use anchor_lang::prelude::*;
use anchor_spl::token::{Mint, Token};
use anchor_spl::token::{self, Transfer};

mod token_staking;
use token_staking::*;

declare_id!("4DwCVbdc5AxpPsVULdpATygFEJrwT87Zf8L6CrbfBmKd");

// Constants
const VESTING_DURATION: i64 = 31536000; // 12 months in seconds
const EARLY_WITHDRAWAL_PENALTY_BPS: u64 = 1000; // 10% penalty (basis points)
const MAX_MULTIPLIER_BPS: u64 = 10000; // 10X max multiplier (10000 = 10.00X)
const MULTIPLIER_GROWTH_RATE: u64 = 50; // 0.5% per week (50 bps)
const REFERRAL_REWARD_BPS: u64 = 1000; // 10% of penalties go to referrer

#[program]
pub mod based_protocol {
    use super::*;

    pub fn initialize_token(_ctx: Context<InitializeToken>) -> Result<()> {
        msg!("BASED Protocol: Token initialized");
        Ok(())
    }

    pub fn initialize_pool(ctx: Context<InitializePool>, reward_rate: u64) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        pool.authority = ctx.accounts.authority.key();
        pool.total_staked = 0;
        pool.reward_rate = reward_rate;
        pool.total_users = 0;
        pool.total_burned = 0;
        pool.bump = ctx.bumps.pool;

        msg!("Staking pool initialized with {} reward_rate", reward_rate);
        Ok(())
    }

    pub fn deposit(ctx: Context<Deposit>, amount: u64, referrer: Option<Pubkey>) -> Result<()> {
        let clock = Clock::get()?;

        // Transfer SOL from user to pool
        let cpi_accounts = anchor_lang::system_program::Transfer {
            from: ctx.accounts.user.to_account_info(),
            to: ctx.accounts.pool.to_account_info(),
        };
        let cpi_ctx = CpiContext::new(ctx.accounts.system_program.to_account_info(), cpi_accounts);
        anchor_lang::system_program::transfer(cpi_ctx, amount)?;

        let pool = &mut ctx.accounts.pool;
        let user_stake = &mut ctx.accounts.user_stake;

        // Set referrer on FIRST deposit only
        if user_stake.amount == 0 {
            if let Some(ref_pubkey) = referrer {
                user_stake.referrer = Some(ref_pubkey);
                msg!("Referrer set: {:?}", ref_pubkey);
            }
            user_stake.vesting_start = clock.unix_timestamp;
            user_stake.multiplier_points = 0;
            pool.total_users = pool.total_users.checked_add(1).ok_or(ErrorCode::MathOverflow)?;
            user_stake.leaderboard_position = pool.total_users;
        } else {
            // Update multiplier based on time staked
            let time_since_last = clock.unix_timestamp - user_stake.last_stake_time;
            user_stake.total_time_staked = user_stake.total_time_staked
                .checked_add(time_since_last)
                .ok_or(ErrorCode::MathOverflow)?;

            let weeks_staked = user_stake.total_time_staked / 604800;
            let new_multiplier = (weeks_staked as u64)
                .checked_mul(MULTIPLIER_GROWTH_RATE)
                .ok_or(ErrorCode::MathOverflow)?
                .min(MAX_MULTIPLIER_BPS);

            user_stake.multiplier_points = new_multiplier;
        }

        pool.total_staked = pool.total_staked
            .checked_add(amount)
            .ok_or(ErrorCode::MathOverflow)?;

        user_stake.owner = ctx.accounts.user.key();
        user_stake.amount = user_stake.amount
            .checked_add(amount)
            .ok_or(ErrorCode::MathOverflow)?;
        user_stake.last_stake_time = clock.unix_timestamp;
        user_stake.bump = ctx.bumps.user_stake;

        msg!(
            "Deposited {} lamports. Total: {}. Multiplier: {} bps. Rank: {}",
            amount,
            user_stake.amount,
            user_stake.multiplier_points,
            user_stake.leaderboard_position
        );
        Ok(())
    }

    pub fn withdraw(ctx: Context<Withdraw>, amount: u64) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        let user_stake = &mut ctx.accounts.user_stake;
        let clock = Clock::get()?;

        require!(user_stake.amount >= amount, ErrorCode::InsufficientFunds);
        
        // Validate pool has enough balance
        require!(
            pool.to_account_info().lamports() >= amount,
            ErrorCode::InsufficientPoolBalance
        );

        let time_staked = clock.unix_timestamp - user_stake.vesting_start;

        let penalty_amount = if time_staked < (VESTING_DURATION / 2) {
            amount
                .checked_mul(EARLY_WITHDRAWAL_PENALTY_BPS)
                .ok_or(ErrorCode::MathOverflow)?
                .checked_div(10_000)
                .ok_or(ErrorCode::MathOverflow)?
        } else if time_staked < VESTING_DURATION {
            amount
                .checked_mul(500)
                .ok_or(ErrorCode::MathOverflow)?
                .checked_div(10_000)
                .ok_or(ErrorCode::MathOverflow)?
        } else {
            0
        };

        let withdrawal_amount = amount.checked_sub(penalty_amount).ok_or(ErrorCode::MathOverflow)?;

        // If user has referrer, give them 10% of penalty
        if penalty_amount > 0 && user_stake.referrer.is_some() {
            let referral_reward = penalty_amount
                .checked_mul(REFERRAL_REWARD_BPS)
                .ok_or(ErrorCode::MathOverflow)?
                .checked_div(10_000)
                .ok_or(ErrorCode::MathOverflow)?;
            
            user_stake.referral_rewards_pending = user_stake.referral_rewards_pending
                .checked_add(referral_reward)
                .ok_or(ErrorCode::MathOverflow)?;
            
            msg!("Referrer earned {} lamports from penalty", referral_reward);
        }

        **pool.to_account_info().try_borrow_mut_lamports()? = pool
            .to_account_info()
            .lamports()
            .checked_sub(withdrawal_amount)
            .ok_or(ErrorCode::InsufficientFunds)?;

        **ctx.accounts.user.to_account_info().try_borrow_mut_lamports()? = ctx
            .accounts
            .user
            .to_account_info()
            .lamports()
            .checked_add(withdrawal_amount)
            .ok_or(ErrorCode::MathOverflow)?;

        pool.total_staked = pool.total_staked.checked_sub(amount).ok_or(ErrorCode::MathOverflow)?;
        user_stake.amount = user_stake.amount.checked_sub(amount).ok_or(ErrorCode::MathOverflow)?;

        if user_stake.amount == 0 {
            user_stake.multiplier_points = 0;
            user_stake.total_time_staked = 0;
        }

        msg!(
            "Withdrew {} lamports. Penalty: {}. Net: {}. Remaining: {}",
            amount,
            penalty_amount,
            withdrawal_amount,
            user_stake.amount
        );
        Ok(())
    }

    pub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        let user_stake = &mut ctx.accounts.user_stake;
        let clock = Clock::get()?;

        let time_staked_i64 = clock
            .unix_timestamp
            .checked_sub(user_stake.last_stake_time)
            .ok_or(ErrorCode::TimeCalculationError)?;
        require!(time_staked_i64 >= 0, ErrorCode::TimeCalculationError);

        let time_staked = time_staked_i64 as u128;
        let user_amount = user_stake.amount as u128;
        let reward_rate = pool.reward_rate as u128;
        let base_multiplier: u128 = 5000;
        let total_multiplier = base_multiplier + (user_stake.multiplier_points as u128);

        const YEAR_SECONDS: u128 = 31_536_000u128;

        let base_rewards = user_amount
            .checked_mul(reward_rate)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_mul(time_staked)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(10_000u128)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(YEAR_SECONDS)
            .ok_or(ErrorCode::MathOverflow)?;

        let total_rewards = base_rewards
            .checked_mul(total_multiplier)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(5000u128)
            .ok_or(ErrorCode::MathOverflow)?;

        let rewards = total_rewards as u64;

        let vesting_time = clock.unix_timestamp - user_stake.vesting_start;
        let vesting_progress = if vesting_time >= VESTING_DURATION {
            10_000u64
        } else {
            (vesting_time as u64)
                .checked_mul(10_000)
                .ok_or(ErrorCode::MathOverflow)?
                .checked_div(VESTING_DURATION as u64)
                .ok_or(ErrorCode::MathOverflow)?
        };

        let vested_rewards = rewards
            .checked_mul(vesting_progress)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(10_000)
            .ok_or(ErrorCode::MathOverflow)?;

        let escrowed_rewards = rewards.checked_sub(vested_rewards).ok_or(ErrorCode::MathOverflow)?;

        // ✅ FIX: Actually transfer vested rewards to user
        if vested_rewards > 0 {
            require!(
                pool.to_account_info().lamports() >= vested_rewards,
                ErrorCode::InsufficientPoolBalance
            );

            **pool.to_account_info().try_borrow_mut_lamports()? = pool
                .to_account_info()
                .lamports()
                .checked_sub(vested_rewards)
                .ok_or(ErrorCode::InsufficientFunds)?;

            **ctx.accounts.user.to_account_info().try_borrow_mut_lamports()? = ctx
                .accounts
                .user
                .to_account_info()
                .lamports()
                .checked_add(vested_rewards)
                .ok_or(ErrorCode::MathOverflow)?;
        }

        user_stake.escrowed_rewards = user_stake
            .escrowed_rewards
            .checked_add(escrowed_rewards)
            .ok_or(ErrorCode::MathOverflow)?;
        
        user_stake.total_rewards_earned = user_stake
            .total_rewards_earned
            .checked_add(rewards)
            .ok_or(ErrorCode::MathOverflow)?;
        
        user_stake.last_stake_time = clock.unix_timestamp;

        msg!(
            "Claimed {} lamports. Vested: {}. Locked: {}. Total locked: {}",
            rewards,
            vested_rewards,
            escrowed_rewards,
            user_stake.escrowed_rewards
        );
        Ok(())
    }

    // ✅ FIX: Actually transfer referral rewards
    pub fn claim_referral_rewards(ctx: Context<ClaimReferralRewards>) -> Result<()> {
        let user_stake = &mut ctx.accounts.user_stake;
        let pool = &mut ctx.accounts.pool;
        
        require!(user_stake.referral_rewards_pending > 0, ErrorCode::NoReferralRewards);
        
        let amount = user_stake.referral_rewards_pending;
        
        require!(
            pool.to_account_info().lamports() >= amount,
            ErrorCode::InsufficientPoolBalance
        );

        **pool.to_account_info().try_borrow_mut_lamports()? = pool
            .to_account_info()
            .lamports()
            .checked_sub(amount)
            .ok_or(ErrorCode::InsufficientFunds)?;

        **ctx.accounts.user.to_account_info().try_borrow_mut_lamports()? = ctx
            .accounts
            .user
            .to_account_info()
            .lamports()
            .checked_add(amount)
            .ok_or(ErrorCode::MathOverflow)?;
        
        user_stake.referral_rewards_pending = 0;
        user_stake.total_referral_rewards_claimed = user_stake
            .total_referral_rewards_claimed
            .checked_add(amount)
            .ok_or(ErrorCode::MathOverflow)?;
        
        msg!(
            "Claimed {} lamports in referral rewards. Total: {}",
            amount,
            user_stake.total_referral_rewards_claimed
        );
        Ok(())
    }

    pub fn get_leaderboard_stats(ctx: Context<GetLeaderboardStats>) -> Result<()> {
        let user_stake = &ctx.accounts.user_stake;
        
        msg!("Leaderboard Stats:");
        msg!("  Rank: {}", user_stake.leaderboard_position);
        msg!("  Staked: {}", user_stake.amount);
        msg!("  Multiplier: {} bps", user_stake.multiplier_points);
        msg!("  Total earned: {}", user_stake.total_rewards_earned);
        msg!("  Referral earnings: {}", user_stake.total_referral_rewards_claimed);
        Ok(())
    }

    pub fn calculate_rewards(ctx: Context<CalculateRewards>) -> Result<u64> {
        let pool = &ctx.accounts.pool;
        let user_stake = &ctx.accounts.user_stake;
        let clock = Clock::get()?;

        let time_staked_i64 = clock
            .unix_timestamp
            .checked_sub(user_stake.last_stake_time)
            .ok_or(ErrorCode::TimeCalculationError)?;
        require!(time_staked_i64 >= 0, ErrorCode::TimeCalculationError);

        let time_staked = time_staked_i64 as u128;
        let user_amount = user_stake.amount as u128;
        let reward_rate = pool.reward_rate as u128;

        let base_multiplier: u128 = 5000;
        let total_multiplier = base_multiplier + (user_stake.multiplier_points as u128);

        const YEAR_SECONDS: u128 = 31_536_000u128;

        let base_rewards = user_amount
            .checked_mul(reward_rate)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_mul(time_staked)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(10_000u128)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(YEAR_SECONDS)
            .ok_or(ErrorCode::MathOverflow)?;

        let total_rewards = base_rewards
            .checked_mul(total_multiplier)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(5000u128)
            .ok_or(ErrorCode::MathOverflow)?;

        let rewards = total_rewards as u64;
        msg!(
            "Pending rewards: {} lamports ({} bps multiplier)",
            rewards,
            total_multiplier
        );
        Ok(rewards)
    }

    // TOKEN STAKING FUNCTIONS
    pub fn initialize_token_pool(
        ctx: Context<InitializeTokenPool>,
        reward_rate: u64,
    ) -> Result<()> {
        let token_pool = &mut ctx.accounts.token_pool;
        token_pool.authority = ctx.accounts.authority.key();
        token_pool.token_mint = ctx.accounts.token_mint.key();
        token_pool.total_staked = 0;
        token_pool.reward_rate = reward_rate;
        token_pool.total_users = 0;
        token_pool.bump = ctx.bumps.token_pool;
        msg!("Token staking pool initialized for mint: {:?}", token_pool.token_mint);
        Ok(())
    }

    pub fn deposit_token(
        ctx: Context<DepositToken>,
        amount: u64,
        referrer: Option<Pubkey>,
    ) -> Result<()> {
        let clock = Clock::get()?;

        let cpi_accounts = Transfer {
            from: ctx.accounts.user_token_account.to_account_info(),
            to: ctx.accounts.pool_token_account.to_account_info(),
            authority: ctx.accounts.user.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
        token::transfer(cpi_ctx, amount)?;

        let token_pool = &mut ctx.accounts.token_pool;
        let token_user_stake = &mut ctx.accounts.token_user_stake;

        if token_user_stake.amount == 0 {
            if let Some(ref_pubkey) = referrer {
                token_user_stake.referrer = Some(ref_pubkey);
                msg!("Referrer set: {:?}", ref_pubkey);
            }
            token_user_stake.vesting_start = clock.unix_timestamp;
            token_user_stake.multiplier_points = 0;
            token_pool.total_users = token_pool.total_users
                .checked_add(1)
                .ok_or(ErrorCode::MathOverflow)?;
            token_user_stake.leaderboard_position = token_pool.total_users;
        } else {
            let time_since_last = clock.unix_timestamp - token_user_stake.last_stake_time;
            token_user_stake.total_time_staked = token_user_stake.total_time_staked
                .checked_add(time_since_last)
                .ok_or(ErrorCode::MathOverflow)?;
            
            let weeks_staked = token_user_stake.total_time_staked / 604800;
            let new_multiplier = (weeks_staked as u64)
                .checked_mul(MULTIPLIER_GROWTH_RATE)
                .ok_or(ErrorCode::MathOverflow)?
                .min(MAX_MULTIPLIER_BPS);
            token_user_stake.multiplier_points = new_multiplier;
        }

        token_pool.total_staked = token_pool.total_staked
            .checked_add(amount)
            .ok_or(ErrorCode::MathOverflow)?;

        token_user_stake.owner = ctx.accounts.user.key();
        token_user_stake.amount = token_user_stake.amount
            .checked_add(amount)
            .ok_or(ErrorCode::MathOverflow)?;
        token_user_stake.last_stake_time = clock.unix_timestamp;
        token_user_stake.bump = ctx.bumps.token_user_stake;

        msg!("Deposited {} tokens. Total staked: {}", amount, token_user_stake.amount);
        Ok(())
    }

    pub fn withdraw_token(ctx: Context<WithdrawToken>, amount: u64) -> Result<()> {
        let token_user_stake = &mut ctx.accounts.token_user_stake;
        let token_pool = &mut ctx.accounts.token_pool;
        let clock = Clock::get()?;

        require!(
            token_user_stake.amount >= amount,
            ErrorCode::InsufficientFunds
        );

        let time_staked = clock.unix_timestamp - token_user_stake.vesting_start;
        let penalty_amount = if time_staked < 2592000 {
            amount.checked_mul(2500).ok_or(ErrorCode::MathOverflow)? / 10000
        } else if time_staked < 7776000 {
            amount.checked_mul(1500).ok_or(ErrorCode::MathOverflow)? / 10000
        } else if time_staked < 15552000 {
            amount.checked_mul(1000).ok_or(ErrorCode::MathOverflow)? / 10000
        } else if time_staked < VESTING_DURATION {
            amount.checked_mul(500).ok_or(ErrorCode::MathOverflow)? / 10000
        } else {
            0
        };

        let withdraw_amount = amount.checked_sub(penalty_amount).ok_or(ErrorCode::MathOverflow)?;

        let seeds = &[
            b"token_pool".as_ref(),
            token_pool.token_mint.as_ref(),
            &[token_pool.bump],
        ];
        let signer = &[&seeds[..]];

        let cpi_accounts = Transfer {
            from: ctx.accounts.pool_token_account.to_account_info(),
            to: ctx.accounts.user_token_account.to_account_info(),
            authority: token_pool.to_account_info(),
        };
        let cpi_program = ctx.accounts.token_program.to_account_info();
        let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
        token::transfer(cpi_ctx, withdraw_amount)?;

        if penalty_amount > 0 && token_user_stake.referrer.is_some() {
            let referral_reward = penalty_amount
                .checked_mul(REFERRAL_REWARD_BPS)
                .ok_or(ErrorCode::MathOverflow)?
                .checked_div(10000)
                .ok_or(ErrorCode::MathOverflow)?;
            
            token_user_stake.referral_rewards_pending = token_user_stake
                .referral_rewards_pending
                .checked_add(referral_reward)
                .ok_or(ErrorCode::MathOverflow)?;
            
            msg!("Referral reward {} tokens pending", referral_reward);
        }

        token_user_stake.amount = token_user_stake.amount
            .checked_sub(amount)
            .ok_or(ErrorCode::MathOverflow)?;

        token_pool.total_staked = token_pool.total_staked
            .checked_sub(amount)
            .ok_or(ErrorCode::MathOverflow)?;

        msg!(
            "Withdrew {} tokens (penalty: {}). Remaining: {}",
            withdraw_amount,
            penalty_amount,
            token_user_stake.amount
        );
        Ok(())
    }

    pub fn claim_token_rewards(ctx: Context<ClaimTokenRewards>) -> Result<()> {
        let token_pool = &ctx.accounts.token_pool;
        let token_user_stake = &mut ctx.accounts.token_user_stake;
        let clock = Clock::get()?;

        let time_staked = clock.unix_timestamp
            .checked_sub(token_user_stake.last_stake_time)
            .ok_or(ErrorCode::TimeCalculationError)?;
        
        let base_multiplier: u128 = 5000;
        let total_multiplier = base_multiplier + (token_user_stake.multiplier_points as u128);

        let base_rewards = (token_user_stake.amount as u128)
            .checked_mul(token_pool.reward_rate as u128)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_mul(time_staked as u128)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(10_000u128)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(31_536_000u128)
            .ok_or(ErrorCode::MathOverflow)?;

        let total_rewards = base_rewards
            .checked_mul(total_multiplier)
            .ok_or(ErrorCode::MathOverflow)?
            .checked_div(5000u128)
            .ok_or(ErrorCode::MathOverflow)?;

        let rewards = total_rewards as u64;

        if rewards > 0 {
            let seeds = &[
                b"token_pool".as_ref(),
                token_pool.token_mint.as_ref(),
                &[token_pool.bump],
            ];
            let signer = &[&seeds[..]];

            let cpi_accounts = Transfer {
                from: ctx.accounts.pool_token_account.to_account_info(),
                to: ctx.accounts.user_token_account.to_account_info(),
                authority: token_pool.to_account_info(),
            };
            let cpi_program = ctx.accounts.token_program.to_account_info();
            let cpi_ctx = CpiContext::new_with_signer(cpi_program, cpi_accounts, signer);
            token::transfer(cpi_ctx, rewards)?;

            token_user_stake.total_rewards_earned = token_user_stake.total_rewards_earned
                .checked_add(rewards)
                .ok_or(ErrorCode::MathOverflow)?;
            
            token_user_stake.last_stake_time = clock.unix_timestamp;

            msg!("Claimed {} token rewards", rewards);
        }

        Ok(())
    }

    // BUYBACK & BURN
    pub fn execute_buyback(ctx: Context<ExecuteBuyback>, amount: u64) -> Result<()> {
        let pool = &mut ctx.accounts.pool;
        pool.total_burned = pool.total_burned.checked_add(amount).ok_or(ErrorCode::MathOverflow)?;
        msg!("Burned {} tokens. Total burned: {}", amount, pool.total_burned);
        Ok(())
    }

    pub fn get_burn_stats(ctx: Context<GetBurnStats>) -> Result<u64> {
        Ok(ctx.accounts.pool.total_burned)
    }

    // VE LOCKING
    pub fn create_lock(
        ctx: Context<CreateLock>,
        amount: u64,
        lock_days: u64,
    ) -> Result<()> {
        let ve_lock = &mut ctx.accounts.ve_lock;
        let clock = Clock::get()?;
        
        ve_lock.owner = ctx.accounts.owner.key();
        ve_lock.amount = amount;
        ve_lock.lock_start = clock.unix_timestamp;
        ve_lock.lock_end = clock.unix_timestamp + (lock_days as i64 * 86400);
        ve_lock.lock_duration_days = lock_days;
        
        ve_lock.ve_based_balance = match lock_days {
            90 => amount * 25 / 100,
            180 => amount * 50 / 100,
            365 => amount,
            730 => amount * 2,
            _ => amount / 4,
        };
        
        ve_lock.bump = ctx.bumps.ve_lock;
        
        msg!("Created lock: {} tokens for {} days = {} ve$BASED", 
             amount, lock_days, ve_lock.ve_based_balance);
        
        Ok(())
    }


    pub fn withdraw_treasury(
        ctx: Context<WithdrawTreasury>,
        amount: u64,
    ) -> Result<()> {
        **ctx.accounts.treasury.to_account_info().try_borrow_mut_lamports()? = ctx
            .accounts
            .treasury
            .to_account_info()
            .lamports()
            .checked_sub(amount)
            .ok_or(ErrorCode::InsufficientFunds)?;

        **ctx.accounts.recipient.to_account_info().try_borrow_mut_lamports()? = ctx
            .accounts
            .recipient
            .to_account_info()
            .lamports()
            .checked_add(amount)
            .ok_or(ErrorCode::MathOverflow)?;

        msg!("Withdrew {} lamports from treasury", amount);
        Ok(())
    }
}

// ACCOUNT STRUCTS
#[derive(Accounts)]
pub struct InitializeToken<'info> {
    #[account(
        init,
        payer = authority,
        mint::decimals = 9,
        mint::authority = authority.key(),
    )]
    pub mint: Account<'info, Mint>,

    #[account(mut)]
    pub authority: Signer<'info>,

    pub token_program: Program<'info, Token>,
    pub system_program: Program<'info, System>,
    pub rent: Sysvar<'info, Rent>,
}

#[account]
pub struct StakingPool {
    pub authority: Pubkey,
    pub total_staked: u64,
    pub total_burned: u64,
    pub reward_rate: u64,
    pub total_users: u64,
    pub bump: u8,
}

#[account]
pub struct UserStake {
    pub owner: Pubkey,
    pub amount: u64,
    pub reward_debt: u64,
    pub last_stake_time: i64,
    pub escrowed_rewards: u64,
    pub vesting_start: i64,
    pub multiplier_points: u64,
    pub total_time_staked: i64,
    pub referrer: Option<Pubkey>,
    pub referral_rewards_pending: u64,
    pub total_referral_rewards_claimed: u64,
    pub leaderboard_position: u64,
    pub total_rewards_earned: u64,
    pub bump: u8,
}

#[derive(Accounts)]
pub struct InitializePool<'info> {
    #[account(
        init,
        payer = authority,
        space = 8 + 32 + 8 + 8 + 8 + 8 + 1,
        seeds = [b"pool"],
        bump,
    )]
    pub pool: Account<'info, StakingPool>,

    #[account(mut)]
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Deposit<'info> {
    #[account(mut, seeds = [b"pool"], bump = pool.bump)]
    pub pool: Account<'info, StakingPool>,

    #[account(
        init_if_needed,
        payer = user,
        space = 8 + 32 + 8 + 8 + 8 + 8 + 8 + 8 + 8 + 33 + 8 + 8 + 8 + 8 + 1,
        seeds = [b"user_stake", user.key().as_ref()],
        bump,
    )]
    pub user_stake: Account<'info, UserStake>,

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct Withdraw<'info> {
    #[account(mut, seeds = [b"pool"], bump = pool.bump)]
    pub pool: Account<'info, StakingPool>,

    #[account(mut, seeds = [b"user_stake", user.key().as_ref()], bump = user_stake.bump)]
    pub user_stake: Account<'info, UserStake>,

    #[account(mut)]
    pub user: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct ClaimRewards<'info> {
    #[account(mut, seeds = [b"pool"], bump = pool.bump)]
    pub pool: Account<'info, StakingPool>,

    #[account(mut, seeds = [b"user_stake", user.key().as_ref()], bump = user_stake.bump)]
    pub user_stake: Account<'info, UserStake>,

    #[account(mut)]
    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct ClaimReferralRewards<'info> {
    #[account(mut, seeds = [b"pool"], bump = pool.bump)]
    pub pool: Account<'info, StakingPool>,
    
    #[account(mut, seeds = [b"user_stake", user.key().as_ref()], bump = user_stake.bump)]
    pub user_stake: Account<'info, UserStake>,

    #[account(mut)]
    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct GetLeaderboardStats<'info> {
    #[account(seeds = [b"user_stake", user.key().as_ref()], bump = user_stake.bump)]
    pub user_stake: Account<'info, UserStake>,

    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct CalculateRewards<'info> {
    #[account(seeds = [b"pool"], bump = pool.bump)]
    pub pool: Account<'info, StakingPool>,

    #[account(seeds = [b"user_stake", user.key().as_ref()], bump = user_stake.bump)]
    pub user_stake: Account<'info, UserStake>,

    pub user: Signer<'info>,
}

#[derive(Accounts)]
pub struct ExecuteBuyback<'info> {
    #[account(mut)]
    pub pool: Account<'info, StakingPool>,
    
    #[account(mut)]
    pub treasury: SystemAccount<'info>,
    
    #[account(mut)]
    pub burn_account: SystemAccount<'info>,
    
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct GetBurnStats<'info> {
    pub pool: Account<'info, StakingPool>,
}

#[account]
pub struct VeBasedLock {
    pub owner: Pubkey,
    pub amount: u64,
    pub lock_start: i64,
    pub lock_end: i64,
    pub lock_duration_days: u64,
    pub ve_based_balance: u64,
    pub bump: u8,
}

#[derive(Accounts)]
pub struct CreateLock<'info> {
    #[account(
        init,
        payer = owner,
        space = 8 + 32 + 8 + 8 + 8 + 8 + 8 + 1,
        seeds = [b"ve_lock", owner.key().as_ref()],
        bump
    )]
    pub ve_lock: Account<'info, VeBasedLock>,
    
    #[account(mut)]
    pub owner: Signer<'info>,
    
    pub system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct WithdrawTreasury<'info> {
    #[account(mut)]
    pub pool: Account<'info, StakingPool>,
    
    #[account(mut)]
    pub treasury: SystemAccount<'info>,
    
    #[account(mut)]
    pub recipient: SystemAccount<'info>,
    
    pub authority: Signer<'info>,
    pub system_program: Program<'info, System>,
}

#[error_code]
pub enum ErrorCode {
    #[msg("Unauthorized access")]
    Unauthorized,
    #[msg("Insufficient funds to withdraw")]
    InsufficientFunds,
    #[msg("Math overflow")]
    MathOverflow,
    #[msg("Time calculation error (clock skew or invalid last stake time)")]
    TimeCalculationError,
    #[msg("No referral rewards available")]
    NoReferralRewards,
    #[msg("Insufficient pool balance")]
    InsufficientPoolBalance,
}

// stBSOL Liquid Staking Token
#[account]
pub struct StBsolMint {
    pub mint: Pubkey,           // Token mint address
    pub total_staked: u64,      // Total SOL staked
    pub total_st_bsol: u64,     // Total stBSOL supply
    pub authority: Pubkey,      // Protocol authority
    pub bump: u8,
}

impl StBsolMint {
    pub const LEN: usize = 8 + 32 + 8 + 8 + 32 + 1;
    
    // Calculate exchange rate: stBSOL -> SOL
    pub fn get_exchange_rate(&self) -> u64 {
        if self.total_st_bsol == 0 {
            return 1_000_000_000; // 1:1 initially (9 decimals)
        }
        // SOL per stBSOL = total_staked / total_st_bsol
        (self.total_staked as u128 * 1_000_000_000 / self.total_st_bsol as u128) as u64
    }
}

use anchor_spl::token::{self, Token, TokenAccount, Mint, MintTo, Burn};
use anchor_spl::associated_token::AssociatedToken;

// stBSOL Liquid Staking Token State
#[account]
pub struct StBsolState {
    pub mint: Pubkey,           // stBSOL token mint
    pub total_sol_staked: u64,  // Total SOL in protocol
    pub total_stbsol_supply: u64, // Total stBSOL minted
    pub authority: Pubkey,      // Protocol authority
    pub bump: u8,
}

impl StBsolState {
    pub const LEN: usize = 8 + 32 + 8 + 8 + 32 + 1;
    
    // Get current exchange rate (SOL per stBSOL, 9 decimals)
    pub fn sol_per_stbsol(&self) -> u64 {
        if self.total_stbsol_supply == 0 {
            return 1_000_000_000; // 1:1 initially
        }
        ((self.total_sol_staked as u128 * 1_000_000_000) / self.total_stbsol_supply as u128) as u64
    }
    
    // Calculate stBSOL to mint for SOL deposited
    pub fn sol_to_stbsol(&self, sol_amount: u64) -> u64 {
        if self.total_stbsol_supply == 0 {
            return sol_amount; // 1:1 for first deposit
        }
        ((sol_amount as u128 * self.total_stbsol_supply as u128) / self.total_sol_staked as u128) as u64
    }
    
    // Calculate SOL to return for stBSOL burned
    pub fn stbsol_to_sol(&self, stbsol_amount: u64) -> u64 {
        ((stbsol_amount as u128 * self.total_sol_staked as u128) / self.total_stbsol_supply as u128) as u64
    }
}
